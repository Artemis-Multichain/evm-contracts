This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-31T00:58:56.705Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.devcontainer/
  devcontainer.json
  Dockerfile
contracts/
  mock/
    SedaProverMock.sol
  ArtemisV3.sol
  AutomatedSedaPriceFeed.sol
  NFTMarketplace.sol
ignition/
  deployments/
    chain-84532/
      deployed_addresses.json
  modules/
    AutomatedSedaPriceFeedModule.ts
    NFTMarketplaceModule.ts
  sedaUtils.ts
tasks/
  create-nft.ts
  get-eth-price.ts
  latestAnswer.ts
  mint-nft.ts
  scope.ts
  transmit.ts
  update-eth-price.ts
  utils.ts
test/
  PriceFeed.ts
.gitignore
hardhat.config.ts
LICENSE
package.json
README.md
seda.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .devcontainer/devcontainer.json
================
{
	"name": "seda-hardhat-starter-kit",
	"build": {
		"dockerfile": "Dockerfile"
	},
	"remoteUser": "node",
	"features": {
		"ghcr.io/devcontainers/features/common-utils:2": {}
	},
	"customizations": {
		"vscode": {
			"extensions": [
				"NomicFoundation.hardhat-solidity"
			]
		}
	}
}

================
File: .devcontainer/Dockerfile
================
FROM node:20

# Install basic development tools
RUN apt update && apt install -y less man-db sudo

# Ensure default `node` user has access to `sudo`
ARG USERNAME=node
RUN echo $USERNAME ALL=\(root\) NOPASSWD:ALL > /etc/sudoers.d/$USERNAME \
    && chmod 0440 /etc/sudoers.d/$USERNAME

# Set `DEVCONTAINER` environment variable to help with orientation
ENV DEVCONTAINER=true

# Install additional tools for devcontainer template development
RUN apt install -y jq shellcheck

================
File: contracts/mock/SedaProverMock.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@seda-protocol/contracts/src/SedaProver.sol";

/**
 * @title SedaProverMock
 * @notice This mock contract is used for testing purposes and simulates the behavior of the SedaProver contract.
 * It allows the creation of data requests and the manual setting of data results for testing interactions
 * with the SEDA network.
 */
contract SedaProverMock {
    // Mapping to store data results by their corresponding data request IDs.
    mapping(bytes32 => SedaDataTypes.DataResult) public dataResults;

    // Array to track all posted request IDs (optional, useful for reference or testing).
    bytes32[] public requestIds;

    /**
     * @notice Simulates posting a data request to the SEDA network.
     * @param inputs The inputs required for creating a data request, including the WASM binary ID and memo.
     * @return dataRequestId The unique ID of the created data request (generated via keccak256 hash).
     */
    function postDataRequest(
        SedaDataTypes.DataRequestInputs memory inputs
    ) public returns (bytes32) {
        // Generate a unique data request ID using the binary ID and memo.
        // Note: this is an over-simplification over how data requests IDs are generated.
        bytes32 dataRequestId = keccak256(
            abi.encodePacked(inputs.dr_binary_id, inputs.memo)
        );

        // Store the new data request ID for reference.
        requestIds.push(dataRequestId);

        return dataRequestId;
    }

    /**
     * @notice Manually sets the data result for a specific data request.
     * @dev This function is useful for mocking the result of a data request during testing.
     * @param _requestId The ID of the data request for which the result is being set.
     * @param _consensus Whether the data result reached consensus (true/false).
     * @param _result The actual result of the data request, stored as bytes.
     */
    function setDataResult(
        bytes32 _requestId,
        bool _consensus,
        bytes memory _result
    ) public {
        dataResults[_requestId] = SedaDataTypes.DataResult({
            version: "0.0.1",
            dr_id: _requestId,
            consensus: _consensus,
            exit_code: 0,
            result: _result,
            block_height: uint64(block.number),
            gas_used: 0,
            payback_address: "",
            seda_payload: ""
        });
    }

    /**
     * @notice Retrieves the data result for a specific data request.
     * @param _requestId The ID of the data request whose result is being fetched.
     * @return The stored `SedaDataTypes.DataResult` for the given data request ID.
     */
    function getDataResult(
        bytes32 _requestId
    ) public view returns (SedaDataTypes.DataResult memory) {
        require(dataResults[_requestId].dr_id != bytes32(0), "Data result not found");
        return dataResults[_requestId];
    }
}

================
File: contracts/ArtemisV3.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

contract ArtemisV3 is ERC1155 {
    string private _name;
    string private _symbol;
    uint256 private _currentTokenId;

    mapping(uint256 => uint256) private _tokenSupply;
    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => uint256) private _tokenPrices;

    constructor(string memory name_, string memory symbol_) ERC1155("") {
        _name = name_;
        _symbol = symbol_;
        _currentTokenId = 1;  // Start from 1 instead of 0
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function createNFT(
        uint256 initialSupply,
        string memory tokenURI,
        uint256 price
    ) external returns (uint256) {
        uint256 tokenId = _currentTokenId;
        _currentTokenId += 1;

        _mint(msg.sender, tokenId, initialSupply, "");

        _tokenSupply[tokenId] = initialSupply;
        _tokenURIs[tokenId] = tokenURI;
        _tokenPrices[tokenId] = price;

        return tokenId;
    }

    function mint(uint256 tokenId) external payable {
        require(_tokenSupply[tokenId] > 0, "Invalid token ID");
        require(msg.value == _tokenPrices[tokenId], "Incorrect payment amount");

        _mint(msg.sender, tokenId, 1, "");

        _tokenSupply[tokenId] -= 1;

        if (_tokenSupply[tokenId] == 0) {
            delete _tokenURIs[tokenId];
            delete _tokenPrices[tokenId];
        }
    }

    function setMaxSupply(uint256 tokenId, uint256 maxSupply) external {
        require(
            maxSupply >= _tokenSupply[tokenId],
            "Max supply must be greater than or equal to current supply"
        );

        _tokenSupply[tokenId] = maxSupply;
    }

    function setTokenURI(uint256 tokenId, string memory tokenURI) external {
        _tokenURIs[tokenId] = tokenURI;
    }

    function setTokenPrice(uint256 tokenId, uint256 price) external {
        _tokenPrices[tokenId] = price;
    }

    function getMaxSupply(uint256 tokenId) external view returns (uint256) {
        return _tokenSupply[tokenId];
    }

    function getTokenURI(
        uint256 tokenId
    ) external view returns (string memory) {
        return _tokenURIs[tokenId];
    }

    function getPrice(uint256 tokenId) external view returns (uint256) {
        return _tokenPrices[tokenId];
    }

    function uri(uint256 tokenId) public view override returns (string memory) {
        return _tokenURIs[tokenId];
    }
}

================
File: contracts/AutomatedSedaPriceFeed.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@seda-protocol/contracts/src/SedaProver.sol";
import "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title AutomatedSedaPriceFeed
 * @notice Price feed contract that fetches ETH/USD prices from SEDA network and uses Chainlink Automation for periodic updates
 */
contract AutomatedSedaPriceFeed is AutomationCompatibleInterface, Pausable {
    // State variables
    bytes32 public latestDataRequestId;
    bytes32 public immutable oracleProgramId;
    SedaProver public immutable sedaProverContract;
    
    // Price tracking
    uint256 public lastUpdatedTimestamp;
    uint256 public latestPrice;
    
    // Automation configuration
    uint256 public minUpdateInterval;
    uint256 public lastTimeStamp;
    bool public automationEnabled;
    
    // Events
    event PriceUpdated(bytes32 indexed requestId, uint256 price, uint256 timestamp);
    event RequestSubmitted(bytes32 indexed requestId, uint256 timestamp);
    event AutomationConfigUpdated(uint256 interval, bool enabled);
    
    // Errors
    error InvalidPrice();
    error RequestPending();
    error NoPriceAvailable();
    error InvalidInterval();

    constructor(
        address _sedaProverContract,
        bytes32 _oracleProgramId,
        uint256 _minUpdateInterval
    ) {
        sedaProverContract = SedaProver(_sedaProverContract);
        oracleProgramId = _oracleProgramId;
        
        if (_minUpdateInterval == 0) revert InvalidInterval();
        minUpdateInterval = _minUpdateInterval;
        
        lastTimeStamp = block.timestamp;
        lastUpdatedTimestamp = block.timestamp;
        automationEnabled = true;
    }

    /**
     * @notice Chainlink Automation check function
     * @return upkeepNeeded Boolean indicating if upkeep is needed
     * @return performData Bytes data to be used in performUpkeep (unused)
     */
    function checkUpkeep(bytes calldata /* checkData */)
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = automationEnabled && 
                       (block.timestamp - lastTimeStamp) >= minUpdateInterval &&
                       !paused();
    }

    /**
     * @notice Chainlink Automation perform function - triggers price update
     */
    function performUpkeep(bytes calldata /* performData */) external override {
        if ((block.timestamp - lastTimeStamp) >= minUpdateInterval) {
            lastTimeStamp = block.timestamp;
            transmit();
        }
    }

    /**
     * @notice Submits a new price update request to SEDA network
     * @return requestId The ID of the submitted request
     */
    function transmit() public returns (bytes32) {
        SedaDataTypes.DataRequestInputs memory inputs = SedaDataTypes.DataRequestInputs(
            oracleProgramId,
            "ethusdc",
            oracleProgramId,
            hex"00",
            1,
            hex"00",
            1,
            5000000,
            abi.encodePacked(block.number)
        );

        latestDataRequestId = sedaProverContract.postDataRequest(inputs);
        emit RequestSubmitted(latestDataRequestId, block.timestamp);
        
        // Try to update price immediately if result is available
        // _updatePrice();
        
        return latestDataRequestId;
    }

    /**
     * @notice Gets the latest price from SEDA network
     * @return price The latest ETH/USD price with 6 decimals
     */
    function latestAnswer() public view returns (uint128) {
        if (latestPrice > 0) {
            return uint128(latestPrice);
        }
        
        // If no cached price, try to get latest from SEDA
        if (latestDataRequestId == bytes32(0)) {
            return 0;
        }
        
        SedaDataTypes.DataResult memory dataResult = sedaProverContract.getDataResult(latestDataRequestId);
        
        if (dataResult.consensus) {
            string memory priceStr = string(dataResult.result);
            uint256 price = stringToUint(priceStr);
            
            // Validate price is reasonable
            if (price > 0 && price < 100_000_000_000) { // $100,000 with 6 decimals
                return uint128(price);
            }
        }
        
        return 0;
    }

    /**
     * @notice Internal function to update price from SEDA
     */
    function _updatePrice() internal {
        if (latestDataRequestId == bytes32(0)) {
            return;
        }

        SedaDataTypes.DataResult memory dataResult = sedaProverContract.getDataResult(latestDataRequestId);
        
        if (dataResult.consensus) {
            string memory priceStr = string(dataResult.result);
            uint256 newPrice = stringToUint(priceStr);
            
            // Validate price is reasonable
            if (newPrice > 0 && newPrice < 100_000_000_000) { // $100,000 with 6 decimals
                latestPrice = newPrice;
                lastUpdatedTimestamp = block.timestamp;
                emit PriceUpdated(latestDataRequestId, newPrice, block.timestamp);
            }
        }
    }

    /**
     * @notice Converts a string to uint
     * @param s The string to convert
     * @return The converted uint value
     */
    function stringToUint(string memory s) internal pure returns (uint256) {
        bytes memory b = bytes(s);
        uint256 result = 0;
        for(uint i = 0; i < b.length; i++) {
            uint8 c = uint8(b[i]);
            if (c >= 48 && c <= 57) {
                result = result * 10 + (c - 48);
            }
        }
        return result;
    }

    // Admin functions

    /**
     * @notice Updates the minimum interval between price updates
     * @param newInterval New minimum interval in seconds
     */
    function setMinUpdateInterval(uint256 newInterval) external {
        if (newInterval == 0) revert InvalidInterval();
        minUpdateInterval = newInterval;
        emit AutomationConfigUpdated(newInterval, automationEnabled);
    }

    /**
     * @notice Enables or disables Chainlink Automation
     * @param enabled Whether automation should be enabled
     */
    function setAutomationEnabled(bool enabled) external {
        automationEnabled = enabled;
        emit AutomationConfigUpdated(minUpdateInterval, enabled);
    }

    /**
     * @notice Pauses the contract, preventing price updates
     */
    function pause() external {
        _pause();
    }

    /**
     * @notice Unpauses the contract, allowing price updates
     */
    function unpause() external {
        _unpause();
    }

    // View functions

    /**
     * @notice Gets the timestamp of the latest price update
     * @return The timestamp of the last price update
     */
    function lastUpdateTime() external view returns (uint256) {
        return lastUpdatedTimestamp;
    }

    /**
     * @notice Gets the latest request ID
     * @return The ID of the latest SEDA request
     */
    function getLatestRequestId() external view returns (bytes32) {
        return latestDataRequestId;
    }
}

================
File: contracts/NFTMarketplace.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

interface IPriceFeed {
    function latestAnswer() external view returns (uint128);
}

contract NFTMarketplace is ERC1155, ReentrancyGuard, Pausable {
    // Structs
    struct TokenData {
        uint256 supply;
        uint256 priceUSD;
        string tokenURI;
        bool exists;
        address creator;
        uint256 royaltyPercentage;
    }

    // State variables
    uint256 private _currentTokenId = 1;
    string private _name;
    string private _symbol;
    
    // Token storage
    mapping(uint256 => TokenData) private _tokens;
    
    // Platform fee configuration
    uint256 public creationFee;
    uint256 public platformFee;
    address public feeRecipient;
    
    // Price feed
    IPriceFeed public immutable priceFeed;
    
    // Constants
    uint256 public constant PRICE_DECIMALS = 6;
    uint256 public constant BASIS_POINTS = 10000;
    
    // Events
    event TokenCreated(
        uint256 indexed tokenId, 
        address indexed creator, 
        uint256 supply, 
        uint256 priceUSD,
        uint256 royaltyPercentage
    );
    event TokenMinted(
        uint256 indexed tokenId, 
        address indexed buyer,
        address indexed creator,
        uint256 priceETH,
        uint256 platformFeeAmount,
        uint256 royaltyAmount
    );
    event FeesUpdated(uint256 creationFee, uint256 platformFee);
    event FeeRecipientUpdated(address newRecipient);

    // Errors
    error InvalidPrice();
    error InvalidPayment();
    error InvalidToken();
    error InsufficientSupply();
    error InvalidFeeConfiguration();
    error InvalidRoyaltyPercentage();
    error TransferFailed();

    constructor(
        string memory name_,
        string memory symbol_,
        address _priceFeed,
        uint256 _creationFee,
        uint256 _platformFee,
        address _feeRecipient
    ) ERC1155("") {
        _name = name_;
        _symbol = symbol_;
        priceFeed = IPriceFeed(_priceFeed);
        
        if (_platformFee > 1000) revert InvalidFeeConfiguration(); // Max 10%
        platformFee = _platformFee;
        creationFee = _creationFee;
        feeRecipient = _feeRecipient;
    }

    function createNFT(
        uint256 initialSupply,
        string memory tokenURI,
        uint256 priceUSD,
        uint256 royaltyPercentage
    ) external payable returns (uint256) {
        // Validate inputs
        if (msg.value < creationFee) revert InvalidPayment();
        if (royaltyPercentage > 2000) revert InvalidRoyaltyPercentage(); // Max 20% royalty
        
        uint256 tokenId = _currentTokenId++;
        
        _tokens[tokenId] = TokenData({
            supply: initialSupply,
            priceUSD: priceUSD,
            tokenURI: tokenURI,
            exists: true,
            creator: msg.sender,
            royaltyPercentage: royaltyPercentage
        });
        
        _mint(msg.sender, tokenId, initialSupply, "");
        
        // Transfer creation fee to fee recipient
        (bool success, ) = feeRecipient.call{value: creationFee}("");
        if (!success) revert TransferFailed();
        
        // Refund excess payment if any
        if (msg.value > creationFee) {
            (success, ) = msg.sender.call{value: msg.value - creationFee}("");
            if (!success) revert TransferFailed();
        }
        
        emit TokenCreated(tokenId, msg.sender, initialSupply, priceUSD, royaltyPercentage);
        return tokenId;
    }

    function mint(uint256 tokenId) external payable nonReentrant whenNotPaused {
        TokenData storage token = _tokens[tokenId];
        if (!token.exists) revert InvalidToken();
        if (token.supply == 0) revert InsufficientSupply();
        
        uint256 ethPrice = getEthPrice();
        if (ethPrice == 0) revert InvalidPrice();
        
        // Calculate required ETH amount: (priceUSD * 1e18) / ethPrice
        uint256 requiredETH = (token.priceUSD * 1e18) / ethPrice;
        if (msg.value < requiredETH) revert InvalidPayment();
        
        // Calculate fees
        uint256 platformFeeAmount = (requiredETH * platformFee) / BASIS_POINTS;
        uint256 royaltyAmount = (requiredETH * token.royaltyPercentage) / BASIS_POINTS;
        uint256 creatorAmount = requiredETH - platformFeeAmount - royaltyAmount;
        
        // Transfer platform fee
        (bool success, ) = feeRecipient.call{value: platformFeeAmount}("");
        if (!success) revert TransferFailed();
        
        // Transfer royalty to creator
        (success, ) = token.creator.call{value: royaltyAmount + creatorAmount}("");
        if (!success) revert TransferFailed();
        
        // Mint token
        _mint(msg.sender, tokenId, 1, "");
        token.supply -= 1;
        
        emit TokenMinted(
            tokenId, 
            msg.sender, 
            token.creator, 
            requiredETH, 
            platformFeeAmount, 
            royaltyAmount
        );
        
        // Refund excess payment
        if (msg.value > requiredETH) {
            (success, ) = msg.sender.call{value: msg.value - requiredETH}("");
            if (!success) revert TransferFailed();
        }
    }

    // Price helper function
    function getEthPrice() public view returns (uint256) {
        uint256 price = uint256(priceFeed.latestAnswer());
        
        // Validate the price is reasonable (greater than 0 and less than $100,000)
        if (price > 0 && price < 100_000_000_000) {  // $100,000 with 6 decimals
            return price;
        }
        
        return 0;
    }

    // Getter functions
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function getTokenData(uint256 tokenId) external view returns (TokenData memory) {
        if (!_tokens[tokenId].exists) revert InvalidToken();
        return _tokens[tokenId];
    }

    function getCurrentPriceETH(uint256 tokenId) external view returns (uint256) {
        if (!_tokens[tokenId].exists) revert InvalidToken();
        
        uint256 ethPrice = getEthPrice();
        if (ethPrice == 0) revert InvalidPrice();
        
        uint256 priceUSD = _tokens[tokenId].priceUSD;
        uint256 numerator = priceUSD * 1e18;
        return numerator / ethPrice;
    }

    function uri(uint256 tokenId) public view override returns (string memory) {
        if (!_tokens[tokenId].exists) revert InvalidToken();
        return _tokens[tokenId].tokenURI;
    }

    // Allow contract to receive ETH
    receive() external payable {}
}

================
File: ignition/deployments/chain-84532/deployed_addresses.json
================
{
  "AutomatedSedaPriceFeedModule#AutomatedSedaPriceFeed": "0x9e85C8C22aa93A73E620E3d2eCcCF0cb04598302",
  "NFTMarketplaceModule#NFTMarketplace": "0xc4F130AD9C194FA44026D8E4C7755da52A8418D1"
}

================
File: ignition/modules/AutomatedSedaPriceFeedModule.ts
================
// ignition/modules/AutomatedSedaPriceFeedModule.ts

import { network } from 'hardhat';
import { buildModule } from '@nomicfoundation/hardhat-ignition/modules';
import { getOracleProgramId, getSedaConfig } from '../sedaUtils';

export const AutomatedSedaPriceFeedModule = buildModule('AutomatedSedaPriceFeedModule', (m) => {
  // Contract parameters
  let proverAddress;
  let oracleProgramId;

  // Fetch network-specific parameters
  if (network.name !== 'hardhat') {
    const sedaConfig = getSedaConfig(network.name);
    proverAddress = m.getParameter('sedaProverContract', sedaConfig.proverAddress);
    oracleProgramId = m.getParameter('binaryId', getOracleProgramId());
  } else {
    const sedaProverMock = m.contract('SedaProverMock', []);
    proverAddress = sedaProverMock;
    oracleProgramId = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }

  const priceFeed = m.contract('AutomatedSedaPriceFeed', [
    proverAddress,
    oracleProgramId,
    3600 // 1 hour update interval
  ]);

  return { priceFeed };
});

================
File: ignition/modules/NFTMarketplaceModule.ts
================
// ignition/modules/NFTMarketplaceModule.ts

import { ethers } from 'hardhat';
import { buildModule } from '@nomicfoundation/hardhat-ignition/modules';
import { AutomatedSedaPriceFeedModule } from './AutomatedSedaPriceFeedModule';

const NFTMarketplaceModule = buildModule('NFTMarketplaceModule', (m) => {
  // Import the PriceFeed module
  const { priceFeed } = m.useModule(AutomatedSedaPriceFeedModule);

  // Configuration
  const NAME = 'MyNFTMarketplace';
  const SYMBOL = 'MNFT';
  const CREATION_FEE = ethers.parseEther('0.0001');
  const PLATFORM_FEE = 250; // 2.5%
  const FEE_RECIPIENT = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';

  // Deploy the NFTMarketplace contract using the imported priceFeed
  const marketplace = m.contract('NFTMarketplace', [
    NAME,
    SYMBOL,
    priceFeed, // Use the imported priceFeed contract
    CREATION_FEE,
    PLATFORM_FEE,
    FEE_RECIPIENT,
  ]);

  return { marketplace, priceFeed };
});

export default NFTMarketplaceModule;

================
File: ignition/sedaUtils.ts
================
import dotenv from "dotenv";
import { SedaConfig, networkConfigs } from "../seda.config"

dotenv.config();

/**
 * Fetches the SEDA network configuration based on the provided network name.
 * @param network The name of the network (e.g., 'mainnet', 'goerli', etc.).
 * @returns SedaConfig The configuration object for the given network.
 * @throws Error if the network configuration is not found.
 */
export function getSedaConfig(network: string): SedaConfig {
  const config = networkConfigs[network];
    if (!config) {
      throw new Error(`SEDA network configuration for ${network} not found`);
    }

  return config;
}

/**
 * Retrieves the Oracle Program ID from the environment variables.
 * Ensures the ID is correctly formatted as a hex string.
 * @returns string The Oracle Program ID (hex-encoded).
 * @throws Error if the ORACLE_PROGRAM_ID is not set or invalid.
 */
export function getOracleProgramId(): string {
  // Retrieve Oracle Program ID from environment variables
  const oracleProgramId = process.env.ORACLE_PROGRAM_ID || "";

  // Check if the Oracle Program ID is not empty
  if (!oracleProgramId) {
    throw new Error(`SEDA Data Request Binary ID is unknown. Please set the 'ORACLE_PROGRAM_ID' environment variable.`);
  }

  // Ensure the Oracle Program ID is properly formatted as a hex string
  if (oracleProgramId.startsWith("0x")) {
    return oracleProgramId;
  }

  // Automatically add "0x" if missing
  return `0x${oracleProgramId}`;
}

================
File: tasks/create-nft.ts
================
import { task } from 'hardhat/config';
import { HardhatRuntimeEnvironment } from 'hardhat/types';
import { NFTMarketplace } from '../typechain-types';

task('create-nft', 'Creates a new NFT in the marketplace').setAction(
  async (_, hre: HardhatRuntimeEnvironment) => {
    try {
      // Hardcoded values for testing
      const CONTRACT_ADDRESS = '0x81253985a66D3A479d3377f494a77033c078d462';
      const SUPPLY = 100;
      const URI = 'ipfs://QmXJN8ECeHgWJwKSwNrNhx7ZvxqCpZNjS1KQQ76MyCBKrN'; // Example IPFS URI
      const PRICE_USD = 1_000_000; // $1 with 6 decimals
      const ROYALTY = 250; // 2.5%

      // Get signer
      const [signer] = await hre.ethers.getSigners();
      console.log('Creating NFT from address:', signer.address);

      // Get contract instance
      const marketplace = (await hre.ethers.getContractAt(
        'NFTMarketplace',
        CONTRACT_ADDRESS,
        signer
      )) as unknown as NFTMarketplace;

      // Get creation fee
      const creationFee = await marketplace.creationFee();

      console.log('\nCreating NFT with parameters:');
      console.log('- Supply:', SUPPLY);
      console.log('- URI:', URI);
      console.log('- Price (USD):', PRICE_USD / 1_000_000, 'USD');
      console.log('- Royalty:', ROYALTY / 100, '%');
      console.log(
        '- Creation Fee:',
        hre.ethers.formatEther(creationFee),
        'ETH'
      );

      // Create NFT
      const tx = await marketplace.createNFT(SUPPLY, URI, PRICE_USD, ROYALTY, {
        value: creationFee,
      });

      console.log('\nTransaction submitted:', tx.hash);

      // Wait for transaction confirmation
      const receipt = await tx.wait();

      // Find TokenCreated event
      const event = receipt?.logs
        .map((log) => {
          try {
            return marketplace.interface.parseLog({
              topics: [...log.topics],
              data: log.data,
            });
          } catch {
            return null;
          }
        })
        .find((event) => event?.name === 'TokenCreated');

      if (event && 'args' in event) {
        console.log('\nNFT created successfully! üéâ');
        console.log('- Token ID:', Number(event.args.tokenId));
        console.log('- Creator:', event.args.creator);
        console.log('- Supply:', Number(event.args.supply));
        console.log(
          '- Price (USD):',
          Number(event.args.priceUSD) / 1_000_000,
          'USD'
        );
        console.log(
          '- Royalty:',
          Number(event.args.royaltyPercentage) / 100,
          '%'
        );
      }
    } catch (error) {
      if (error instanceof Error) {
        console.error('\n‚ùå Error creating NFT:', error.message);

        if (error.message.includes('invalid address')) {
          console.error(
            'Make sure to update the CONTRACT_ADDRESS in the task with your deployed contract address!'
          );
        }
        if (error.message.includes('insufficient funds')) {
          console.error(
            'Make sure your account has enough ETH to pay the creation fee!'
          );
        }
      } else {
        console.error('Unknown error occurred');
      }
      process.exit(1);
    }
  }
);

================
File: tasks/get-eth-price.ts
================
import { task } from 'hardhat/config';
import { HardhatRuntimeEnvironment } from 'hardhat/types';
import { AutomatedSedaPriceFeed } from '../typechain-types';
import * as fs from 'fs';
import * as path from 'path';

task(
  'get-eth-price',
  'Gets the current ETH price from the SEDA oracle'
).setAction(async (_, hre: HardhatRuntimeEnvironment) => {
  try {
    // Get contract address from deployment file

    const CONTRACT_ADDRESS = '0x9e85C8C22aa93A73E620E3d2eCcCF0cb04598302';

    if (!CONTRACT_ADDRESS) {
      throw new Error(
        'AutomatedSedaPriceFeed address not found in deployments'
      );
    }

    console.log('Using PriceFeed at:', CONTRACT_ADDRESS);

    // Get contract instance
    const priceFeed = (await hre.ethers.getContractAt(
      'AutomatedSedaPriceFeed',
      CONTRACT_ADDRESS
    )) as unknown as AutomatedSedaPriceFeed;

    console.log('\n=== Price Update Status ===');
    const requestId = await priceFeed.getLatestRequestId();
    console.log('Latest Request ID:', requestId);

    const lastTimestamp = await priceFeed.lastUpdateTime();
    const lastUpdate = new Date(Number(lastTimestamp) * 1000);
    console.log('Last Price Update:', lastUpdate.toLocaleString());

    const automationLastTimestamp = await priceFeed.lastTimeStamp();
    const lastAutomationUpdate = new Date(
      Number(automationLastTimestamp) * 1000
    );
    console.log(
      'Last Automation Check:',
      lastAutomationUpdate.toLocaleString()
    );

    const timeSinceUpdate =
      Math.floor(Date.now() / 1000) - Number(lastTimestamp);
    console.log('Time Since Update:', timeSinceUpdate, 'seconds');

    // Get automation status
    const automationEnabled = await priceFeed.automationEnabled();
    const isPaused = await priceFeed.paused();
    console.log('\n=== Automation Status ===');
    console.log('Automation Enabled:', automationEnabled);
    console.log('Contract Paused:', isPaused);

    // Try to get the price
    console.log('\n=== Price Information ===');
    try {
      // First try to get the raw data to check consensus
      const proverContract = await priceFeed.sedaProverContract();
      const sedaProver = await hre.ethers.getContractAt(
        'SedaProver',
        proverContract
      );

      try {
        const result = await sedaProver.getDataResult(requestId);
        if (!result.consensus) {
          console.log('\n‚è≥ Oracle consensus not yet reached');
          console.log('Please wait 30-60 seconds and try again');
          return;
        }
      } catch (error) {
        console.log('\n‚è≥ Price data not yet available');
        console.log('Please wait 30-60 seconds and try again');
        return;
      }

      // Get the latest price
      const latestPrice = await priceFeed.latestAnswer();

      if (latestPrice.toString() === '0') {
        console.log('\n‚ö†Ô∏è No valid price available yet');
        console.log('\nTroubleshooting steps:');
        console.log('1. Wait longer for oracle consensus (30-60 seconds)');
        console.log('2. Run update-eth-price to request new price');
        console.log('3. Try this command again');
      } else {
        const priceInUSD = Number(latestPrice) / 1_000_000;
        console.log('\nCurrent ETH Price:', priceInUSD.toFixed(2), 'USD');
        console.log('Price Last Updated:', lastUpdate.toLocaleString());
      }
    } catch (error) {
      console.log('\n‚ö†Ô∏è Could not fetch price data');
      console.log('This usually means:');
      console.log('1. Oracle consensus has not been reached yet');
      console.log('2. The price update is still pending');
      console.log('\nPlease wait 30-60 seconds and try again');
    }
  } catch (error) {
    if (error instanceof Error) {
      console.error('\n‚ùå Error:', error.message);

      if (error.message.includes('No deployments found')) {
        console.error(
          'Please deploy the contracts first using the deployment script'
        );
      } else if (error.message.includes('invalid address')) {
        console.error('Invalid contract address in deployment file');
      } else {
        console.log('\nTroubleshooting steps:');
        console.log('1. Check if you have deployed the contracts');
        console.log('2. Run update-eth-price to request new price');
        console.log('3. Wait 30-60 seconds after update-eth-price');
        console.log('4. Try again after waiting');
      }
    } else {
      console.error('Unknown error occurred');
    }
  }
});

================
File: tasks/latestAnswer.ts
================
import { getDeployedContract } from "./utils";
import { priceFeedScope } from "./scope";

/**
 * Task: Fetches the latest answer from the PriceFeed contract.
 * Optional parameter: contract (PriceFeed contract address).
 * If the contract address is not provided, fetches from previous deployments.
 */
priceFeedScope.task("latest-answer", "Calls the latestAnswer function on the PriceFeed contract")
  .addOptionalParam("contract", "The PriceFeed contract address")
  .setAction(async ({ contract }, hre) => {
    try {
      // Fetch the address from previous deployments if not provided
      let priceFeedAddress = contract;
      if (!priceFeedAddress) {
        console.log("No contract address specified, fetching from previous deployments...");
        priceFeedAddress = getDeployedContract(hre.network.config, 'PriceFeedModule#PriceFeed');
        console.log("Contract found:", priceFeedAddress);
      }

      // Get the PriceFeed contract instance
      const priceFeed = await hre.ethers.getContractAt("PriceFeed", priceFeedAddress);

      // Call the latestAnswer function on the contract
      console.log(`\nCalling latestAnswer() on PriceFeed at ${priceFeedAddress}`);
      const latestAnswer = await priceFeed.latestAnswer();
      console.log("Latest Answer:", latestAnswer.toString());
    } catch (error: any) {
      console.error(`An error occurred while fetching the latest answer: ${error.message}`);
    }
  });

================
File: tasks/mint-nft.ts
================
import { task } from 'hardhat/config';
import { HardhatRuntimeEnvironment } from 'hardhat/types';
import { NFTMarketplace } from '../typechain-types';

task('mint-nft', 'Mints an NFT from the marketplace')
  .addParam('tokenId', 'The ID of the NFT to mint')
  .setAction(async (taskArgs, hre: HardhatRuntimeEnvironment) => {
    try {
      const CONTRACT_ADDRESS = '0x81253985a66D3A479d3377f494a77033c078d462';

      // Get signer
      const [signer] = await hre.ethers.getSigners();
      console.log('Minting as:', signer.address);

      // Get contract instance
      const marketplace = (await hre.ethers.getContractAt(
        'NFTMarketplace',
        CONTRACT_ADDRESS,
        signer
      )) as unknown as NFTMarketplace;

      // Get token data
      const tokenData = await marketplace.getTokenData(taskArgs.tokenId);
      console.log('\nToken Details:');
      console.log('- Token ID:', taskArgs.tokenId);
      console.log('- Creator:', tokenData.creator);
      console.log('- Available Supply:', Number(tokenData.supply));
      console.log('- Price (USD):', Number(tokenData.priceUSD) / 1_000_000, 'USD');
      console.log('- Price (USD Raw):', tokenData.priceUSD.toString());
      console.log('- Royalty:', Number(tokenData.royaltyPercentage) / 100, '%');

      // Get ETH price
      const ethPrice = await marketplace.getEthPrice();
      if (ethPrice.toString() === '0') {
        throw new Error('No valid ETH price available. Run update-eth-price first.');
      }
      
      console.log('\nPrice Debug Info:');
      console.log('Raw ETH Price:', ethPrice.toString());
      console.log('ETH Price in USD:', Number(ethPrice) / 1_000_000);
      
      // Calculate required ETH manually
      const priceUSD = tokenData.priceUSD;
      const calculatedETH = (priceUSD * BigInt(1e18)) / ethPrice;
      
      console.log('\nCalculation Debug:');
      console.log('Price USD * 1e18:', (priceUSD * BigInt(1e18)).toString());
      console.log('Divided by ETH price:', calculatedETH.toString());

      // Get contract's calculation
      const requiredETH = await marketplace.getCurrentPriceETH(taskArgs.tokenId);
      console.log('\nRequired ETH (contract):', hre.ethers.formatEther(requiredETH), 'ETH');
      console.log('Required ETH (calculated):', hre.ethers.formatEther(calculatedETH), 'ETH');

      console.log('\nWould you like to continue with the mint? (Price might be incorrect)');
    //   process.exit(0);
      console.log('Required ETH:', hre.ethers.formatEther(requiredETH), 'ETH');

      console.log('\nMinting NFT...');

      // Mint NFT
      const tx = await marketplace.mint(taskArgs.tokenId, {
        value: requiredETH,
      });

      console.log('Transaction submitted:', tx.hash);

      // Wait for confirmation
      const receipt = await tx.wait();

      // Find TokenMinted event
      const event = receipt?.logs
        .map((log) => {
          try {
            return marketplace.interface.parseLog({
              topics: [...log.topics],
              data: log.data,
            });
          } catch {
            return null;
          }
        })
        .find((event) => event?.name === 'TokenMinted');

      if (event && 'args' in event) {
        console.log('\nNFT minted successfully! üéâ');
        console.log('- Token ID:', Number(event.args.tokenId));
        console.log('- Buyer:', event.args.buyer);
        console.log('- Creator:', event.args.creator);
        console.log(
          '- Price Paid:',
          hre.ethers.formatEther(event.args.priceETH),
          'ETH'
        );
        console.log(
          '- Platform Fee:',
          hre.ethers.formatEther(event.args.platformFeeAmount),
          'ETH'
        );
        console.log(
          '- Royalty Paid:',
          hre.ethers.formatEther(event.args.royaltyAmount),
          'ETH'
        );
      }
    } catch (error) {
      if (error instanceof Error) {
        console.error('\n‚ùå Error minting NFT:', error.message);

        if (error.message.includes('InvalidToken')) {
          console.error('This token ID does not exist!');
        }
        if (error.message.includes('InsufficientSupply')) {
          console.error('This NFT is sold out!');
        }
        if (error.message.includes('InvalidPrice')) {
          console.error(
            'No valid price available. Try running update-eth-price first.'
          );
        }
        if (error.message.includes('InvalidPayment')) {
          console.error('Insufficient ETH sent for minting!');
        }
        if (error.message.includes('insufficient funds')) {
          console.error('Your wallet does not have enough ETH!');
        }
      } else {
        console.error('Unknown error occurred');
      }
      process.exit(1);
    }
  });

================
File: tasks/scope.ts
================
import { scope } from "hardhat/config";

/**
 * Defines the scope for pricefeed-related tasks.
 */
export const priceFeedScope = scope("pricefeed", "Interact with the PriceFeed contract");

================
File: tasks/transmit.ts
================
import { getDeployedContract } from "./utils";
import { priceFeedScope } from "./scope";

/**
 * Task: Calls the transmit function on the PriceFeed contract.
 * Optional parameter: contract (PriceFeed contract address).
 * If the contract address is not provided, fetches from previous deployments.
 */
priceFeedScope.task("transmit", "Calls the transmit function on the PriceFeed contract")
  .addOptionalParam("contract", "The PriceFeed contract address")
  .setAction(async ({ contract }, hre) => {
    try {
      // Fetch the address from previous deployments if not provided
      let priceFeedAddress = contract;
      if (!priceFeedAddress) {
        console.log("No contract address specified, fetching from previous deployments...");
        priceFeedAddress = getDeployedContract(hre.network.config, 'PriceFeedModule#PriceFeed');
        console.log("Contract found:", priceFeedAddress);
      }

      // Get the PriceFeed contract instance
      const priceFeed = await hre.ethers.getContractAt("PriceFeed", priceFeedAddress);

      // Call the transmit function
      console.log(`\nCalling transmit() on PriceFeed at ${priceFeedAddress}...`);
      const tx = await priceFeed.transmit();

      // Wait for the transaction
      await tx.wait();
      console.log("Transmit executed successfully.");
    } catch (error: any) {
      console.error("An error occurred during the transmit function:", error.message);
    }
  });

================
File: tasks/update-eth-price.ts
================
import { task } from 'hardhat/config';
import { HardhatRuntimeEnvironment } from 'hardhat/types';
import { AutomatedSedaPriceFeed } from '../typechain-types';
import { getDeployedContract } from './utils';

task(
  'update-eth-price',
  'Triggers a new ETH price request from SEDA network'
).setAction(async (_, hre: HardhatRuntimeEnvironment) => {
  try {
    // Get the deployed contract address from previous deployments
    // let contractAddress;
    // try {
    //   contractAddress = getDeployedContract(
    //     hre.network.config,
    //     'AutomatedSedaPriceFeedModule#automatedSedaPriceFeed'
    //   );
    //   console.log('Contract found at:', contractAddress);
    // } catch (error) {
    //   throw new Error(
    //     'Contract address not found in deployments. Please deploy the contract first.'
    //   );
    // }

    const contractAddress = '0x9e85C8C22aa93A73E620E3d2eCcCF0cb04598302';

    // Get signer
    const [signer] = await hre.ethers.getSigners();
    console.log('Requesting price update as:', signer.address);

    // Get contract instance
    const priceFeed = (await hre.ethers.getContractAt(
      'AutomatedSedaPriceFeed',
      contractAddress,
      signer
    )) as unknown as AutomatedSedaPriceFeed;

    // Show current status
    const oldRequestId = await priceFeed.getLatestRequestId();
    console.log('\nCurrent Request ID:', oldRequestId);

    const lastUpdateTime = await priceFeed.lastUpdateTime();
    const lastUpdate = new Date(Number(lastUpdateTime) * 1000);
    console.log('Last Update:', lastUpdate.toLocaleString());

    // Transmit new price request
    console.log('\nSubmitting new price request...');
    const tx = await priceFeed.transmit();
    console.log('Transaction submitted:', tx.hash);

    // Wait for transaction confirmation
    const receipt = await tx.wait();

    // Parse the RequestSubmitted event
    const event = receipt?.logs
      .map((log) => {
        try {
          return priceFeed.interface.parseLog({
            topics: [...log.topics],
            data: log.data,
          });
        } catch {
          return null;
        }
      })
      .find((event) => event?.name === 'RequestSubmitted');

    if (event && 'args' in event) {
      console.log('\nPrice request submitted successfully! üéâ');
      const timestamp = new Date(Number(event.args.timestamp) * 1000);
      console.log('Request ID:', event.args.requestId);
      console.log('Submitted at:', timestamp.toLocaleString());

      console.log('\nNote: Price update typically takes 30-60 seconds.');
      console.log('Use "get-eth-price" task to check the new price.');
    }
  } catch (error) {
    if (error instanceof Error) {
      console.error('\n‚ùå Error requesting price update:', error.message);

      if (error.message.includes('Contract address not found')) {
        console.error(
          'Please deploy the AutomatedSedaPriceFeed contract first.'
        );
      } else if (error.message.includes('execution reverted')) {
        console.error(
          'Transaction reverted. Check if the contract is paused or if automation is disabled.'
        );
      } else if (error.message.includes('invalid address')) {
        console.error(
          'Invalid contract address. Please verify the deployment.'
        );
      }
    } else {
      console.error('Unknown error occurred');
    }
    process.exit(1);
  }
});

// NFTMarketplaceModule#AutomatedSedaPriceFeed - 0xC88C40E10e6F1019898D8D4BD0b734C7827fd861
// NFTMarketplaceModule#NFTMarketplace - 0x314F0764b463Da95B05002D124ebFE60955a16CF

================
File: tasks/utils.ts
================
import * as fs from "fs";
import * as path from "path";
import { NetworkConfig } from "hardhat/types";

/**
 * Helper function to fetch the deployed contract address from the ignition deployment file.
 * @param network NetworkConfig object containing network details.
 * @param contractName The full name of the contract (as stored in the deployment JSON file).
 * @returns The deployed contract address as a string.
 * @throws Error if the deployment file or contract address is not found.
 */
export function getDeployedContract(network: NetworkConfig, contractName: string): string {
  // Hard-coded deployment path based on network's chain ID
  const deploymentPath = path.join(__dirname, `../ignition/deployments/chain-${network.chainId}/deployed_addresses.json`);

  // Check if the deployment file exists
  if (!fs.existsSync(deploymentPath)) {
    throw new Error(`Deployment file not found for ${contractName} on network ${network.chainId}`);
  }

  // Parse the deployment JSON file to fetch contract addresses
  const deployment = JSON.parse(fs.readFileSync(deploymentPath, "utf-8"));

  // Retrieve the contract address using the contract name as a key
  const address = deployment[contractName];
  if (!address) {
    throw new Error(`Contract ${contractName} not found in deployment file for network ${network.chainId}`);
  }

  return address;
}

================
File: test/PriceFeed.ts
================
import {
    loadFixture,
} from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { expect } from "chai";
import { ethers } from "hardhat";

describe("PriceFeed Contract", function () {
    // Setup the fixture to deploy contracts
    async function deployPriceFeedFixture() {
        // A Data Request WASM binary ID (mock value)
        const drBinaryId = ethers.ZeroHash;

        // Deploy a mock of the SedaProver contract
        const SedaProver = await ethers.getContractFactory("SedaProverMock");
        const sedaProver = await SedaProver.deploy();

        // Deploy the PriceFeed contract
        const PriceFeed = await ethers.getContractFactory("PriceFeed");
        const priceFeed = await PriceFeed.deploy(sedaProver.getAddress(), drBinaryId);

        return { priceFeed, sedaProver };
    }

    /**
     * Test Case 1: No transmission before `latestAnswer`
     * Ensure that calling latestAnswer without transmitting a data request first reverts.
     */
    it("Should revert if data request is not transmitted", async function () {
        const { priceFeed } = await loadFixture(deployPriceFeedFixture);

        // Attempting to call latestAnswer without a transmission should revert
        await expect(priceFeed.latestAnswer()).to.be.revertedWith("No data request transmitted");
    });

    /**
     * Test Case 2: No data result found
     * Ensure that calling latestAnswer after transmission but without setting a data result reverts.
     */
    it("Should revert if data result is not found", async function () {
        const { priceFeed } = await loadFixture(deployPriceFeedFixture);

        // Transmit the data request (but no result set)
        await priceFeed.transmit();

        // latestAnswer should revert due to no data result being set
        await expect(priceFeed.latestAnswer()).to.be.revertedWith("Data result not found");
    });

    /**
     * Test Case 3: Return correct `latestAnswer` with consensus (true)
     * Verify that latestAnswer returns the correct value when consensus is reached.
     */
    it("Should return the correct latest answer if consensus is reached", async function () {
        const { priceFeed, sedaProver } = await loadFixture(deployPriceFeedFixture);

        // Transmit a data request
        await priceFeed.transmit();
        const dataRequestId = await priceFeed.dataRequestId();

        // Set a data result with consensus in the mock contract
        const resultValue = "0x0000000000000000000000000e9de9b0"; // Mock value (245230000)
        await sedaProver.setDataResult(dataRequestId, true, resultValue);

        // latestAnswer should return the expected result when consensus is reached
        const latestAnswer = await priceFeed.latestAnswer();
        expect(latestAnswer).to.equal(245230000);
    });

    /**
      * Test Case 4: Return zero if no consensus reached
      * Ensure that latestAnswer returns 0 when no consensus is reached.
      */
    it("Should return latest answer (zero) if consensus is not reached", async function () {
        const { priceFeed, sedaProver } = await loadFixture(deployPriceFeedFixture);

        // Transmit a data request
        await priceFeed.transmit();
        const dataRequestId = await priceFeed.dataRequestId();

        // Set a data result without consensus (false)
        const resultValue = new ethers.AbiCoder().encode(["uint128"], [BigInt(100)]); // Mock value of 100
        await sedaProver.setDataResult(dataRequestId, false, resultValue);

        // latestAnswer should return 0 since no consensus was reached
        const latestAnswer = await priceFeed.latestAnswer();
        expect(latestAnswer).to.equal(0);
    });

    /**
     * Test Case 5: Successful transmission
     * Ensure that a data request is correctly transmitted and the request ID is valid.
     */
    it("Should successfully transmit a data request and return a valid request ID", async function () {
        const { priceFeed } = await loadFixture(deployPriceFeedFixture);

        // Assert data request id is zero
        let dataRequestId = await priceFeed.dataRequestId();
        expect(dataRequestId).to.be.equal(ethers.ZeroHash);

        // Call the transmit function
        await priceFeed.transmit();

        // Check that the data request ID is valid and stored correctly
        dataRequestId = await priceFeed.dataRequestId();
        expect(dataRequestId).to.not.be.equal(ethers.ZeroHash);
    });
});

================
File: .gitignore
================
node_modules
.env

# Hardhat files
/cache
/artifacts

# TypeChain files
/typechain
/typechain-types

# solidity-coverage files
/coverage
/coverage.json

# Hardhat Ignition default folder for deployments against a local node
ignition/deployments/chain-31337

================
File: hardhat.config.ts
================
import { HardhatUserConfig } from 'hardhat/config';
import '@nomicfoundation/hardhat-toolbox';
import dotenv from 'dotenv';

// PriceFeed Tasks
import './tasks/transmit';
import './tasks/latestAnswer';
import './tasks/create-nft';
import './tasks/update-eth-price';
import './tasks/get-eth-price';
import './tasks/mint-nft';

dotenv.config();

const config: HardhatUserConfig = {
  solidity: '0.8.25',
  networks: {
    baseSepolia: {
      accounts: [process.env.EVM_PRIVATE_KEY || ''],
      url: 'https://sepolia.base.org',
      chainId: 84532,
    },
  },
  etherscan: {
    apiKey: process.env.BASE_SEPOLIA_ETHERSCAN_API_KEY || '',
    customChains: [
      {
        chainId: 84532,
        network: 'baseSepolia',
        urls: {
          apiURL: 'https://api-sepolia.basescan.org/api',
          browserURL: 'https://sepolia.basescan.org',
        },
      },
    ],
  },
};

export default config;

================
File: LICENSE
================
MIT License

Copyright (c) 2024 SEDA protocol

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "seda-hardhat-starter-kit",
  "version": "0.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^5.0.0",
    "dotenv": "^16.4.5",
    "hardhat": "^2.22.10"
  },
  "dependencies": {
    "@chainlink/contracts": "^1.3.0",
    "@openzeppelin/contracts": "^5.1.0",
    "@seda-protocol/contracts": "0.0.2"
  }
}

================
File: README.md
================
<p align="center">
  <a href="https://seda.xyz/">
    <img width="90%" alt="seda-protocol" src="https://www.seda.xyz/images/footer/footer-image.png">
  </a>
</p>

<h1 align="center">
  SEDA Hardhat Starter Kit
</h1>

This starter kit is built on a minimal Hardhat boilerplate, focusing on simplicity to showcase how to interact with the SEDA network. It features a sample consumer contract (PriceFeed) that interacts with the SEDA protocol through a Prover Contract, demonstrating how to create and retrieve data requests on the network.

## Getting Started

Clone the repository and install the dependencies:

```sh
git clone git@github.com:sedaprotocol/seda-hardhat-starter-kit.git
cd seda-hardhat-starter-kit
npm install
```

### Project Structure

This project follows the structure of a typical Hardhat project:

* **contracts/**: Contains the Solidity contracts including PriceFeed.
* **ignition/**: Ignition deployment modules for deploying contracts.
* **tasks/**: Hardhat tasks for interacting with the PriceFeed contract.
* **test/**: Test files for the contracts.

## Compiling and Testing the Contracts

Compile your contracts and run tests to ensure everything works correctly:

```sh
npx hardhat compile
npx hardhat test
```

## Deploying the Contracts

Deploy the `PriceFeed` contract using Hardhat Ignition with a specific SEDA configuration:

```sh
npx hardhat ignition deploy ./ignition/modules/PriceFeed.ts --network baseSepolia --verify
```

> [!NOTE]
> The project includes a `seda.config.ts` file that includes SEDA-specific configurations. This file allows you to define and modify configurations such as the addresses of Prover Contracts on different networks.

## Interacting with Deployed Contracts

Use Hardhat tasks specifically designed for interacting with the PriceFeed contract.

**Transmit a Data Request**: Calls the transmit function on PriceFeed to trigger a data request post on the SEDA network.

```sh
npx hardhat pricefeed transmit --network <network_name>
```

**Fetch Latest Answer**: Calls the latestAnswer function on PriceFeed to get the result of the data request.

```sh
npx hardhat pricefeed latest-answer --network <network_name>
```

## Environment Variables

Configure the .env file with the necessary variables. Here is an example .env file:

```
ORACLE_PROGRAM_ID=YOUR_ORACLE_PROGRAM_ID
EVM_PRIVATE_KEY=YOUR_EVM_PRIVATE_KEY
BASE_SEPOLIA_ETHERSCAN_API_KEY=YOUR_BASESCAN_API_KEY
```

## Additional Resources

* [**SEDA Protocol Documentation**](https://docs.seda.xyz): Learn more about how to build on the SEDA network and interact with data requests.
* [**Hardhat Documentation**](https://hardhat.org/docs): Understand how to use Hardhat for developing, deploying, and testing your contracts.

## License

Contents of this repository are open source under [MIT License](LICENSE).

================
File: seda.config.ts
================
export interface SedaConfig {
  proverAddress: string;
}

export const networkConfigs: { [network: string]: SedaConfig } = {
  baseSepolia: {
    proverAddress: "0xcBC8a3159535BfE276ADaA8604940602e02c5457",
  }
};

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  }
}
